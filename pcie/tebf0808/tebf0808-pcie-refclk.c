/*
 * Phoenix-RTOS
 *
 * TEBF0808 evaluation board PCI Express reference clock initialisation
 *
 * Copyright 2025 Phoenix Systems
 * Author: Dariusz Sabala
 *
 * %LICENSE%
 */

#include <errno.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/platform.h>

#include <phoenix/arch/aarch64/zynqmp/zynqmp.h>

#include <board_config.h>

#include <i2c.h>

#include <pcie.h>

#include <tebf0808-pcie-refclk.h>


#define GPIO_REG_SET_ADDR 0xff0a0000
#define GPIO_REG_SET_SIZE 0x1000


#define SI5345_I2C_ADDRESS  0x69
#define SI5345_PAGE_ADDRESS 0x01


static struct {
	uint32_t *gpio;
} common;


typedef struct {
	uint16_t address; /* MSB byte contains page number, LSB offset within page */
	uint8_t value;    /* value to write to register, acquired from Clock Builder Pro */
} si5345_reg_t;


/* Registers value derived from Trenz example code */
si5345_reg_t const si5345_config[] = {
	{ 0x0B24, 0xD8 },
	{ 0x0B25, 0x00 },
	{ 0x0540, 0x01 },
	{ 0x000B, 0x68 },
	{ 0x0016, 0x02 },
	{ 0x0017, 0x1C },
	{ 0x0018, 0xEE },
	{ 0x0019, 0xDD },
	{ 0x001A, 0xDF },
	{ 0x002B, 0x02 },
	{ 0x002C, 0x01 },
	{ 0x002D, 0x01 },
	{ 0x002E, 0x3B },
	{ 0x002F, 0x00 },
	{ 0x0030, 0x00 },
	{ 0x0031, 0x00 },
	{ 0x0032, 0x00 },
	{ 0x0033, 0x00 },
	{ 0x0034, 0x00 },
	{ 0x0035, 0x00 },
	{ 0x0036, 0x3B },
	{ 0x0037, 0x00 },
	{ 0x0038, 0x00 },
	{ 0x0039, 0x00 },
	{ 0x003A, 0x00 },
	{ 0x003B, 0x00 },
	{ 0x003C, 0x00 },
	{ 0x003D, 0x00 },
	{ 0x003F, 0x11 },
	{ 0x0040, 0x04 },
	{ 0x0041, 0x0B },
	{ 0x0042, 0x00 },
	{ 0x0043, 0x00 },
	{ 0x0044, 0x00 },
	{ 0x0045, 0x0C },
	{ 0x0046, 0x64 },
	{ 0x0047, 0x00 },
	{ 0x0048, 0x00 },
	{ 0x0049, 0x00 },
	{ 0x004A, 0x64 },
	{ 0x004B, 0x00 },
	{ 0x004C, 0x00 },
	{ 0x004D, 0x00 },
	{ 0x004E, 0x05 },
	{ 0x004F, 0x00 },
	{ 0x0050, 0x0F },
	{ 0x0051, 0x03 },
	{ 0x0052, 0x00 },
	{ 0x0053, 0x00 },
	{ 0x0054, 0x00 },
	{ 0x0055, 0x03 },
	{ 0x0056, 0x00 },
	{ 0x0057, 0x00 },
	{ 0x0058, 0x00 },
	{ 0x0059, 0x03 },
	{ 0x005A, 0x00 },
	{ 0x005B, 0x00 },
	{ 0x005C, 0x00 },
	{ 0x005D, 0x01 },
	{ 0x005E, 0x00 },
	{ 0x005F, 0x00 },
	{ 0x0060, 0x00 },
	{ 0x0061, 0x00 },
	{ 0x0062, 0x00 },
	{ 0x0063, 0x00 },
	{ 0x0064, 0x00 },
	{ 0x0065, 0x00 },
	{ 0x0066, 0x00 },
	{ 0x0067, 0x00 },
	{ 0x0068, 0x00 },
	{ 0x0069, 0x00 },
	{ 0x0092, 0x00 },
	{ 0x0093, 0x00 },
	{ 0x0095, 0x00 },
	{ 0x0096, 0x00 },
	{ 0x0098, 0x00 },
	{ 0x009A, 0x02 },
	{ 0x009B, 0x30 },
	{ 0x009D, 0x00 },
	{ 0x009E, 0x20 },
	{ 0x00A0, 0x00 },
	{ 0x00A2, 0x02 },
	{ 0x00A8, 0x43 },
	{ 0x00A9, 0x88 },
	{ 0x00AA, 0x08 },
	{ 0x00AB, 0x00 },
	{ 0x00AC, 0x00 },
	{ 0x0102, 0x01 },
	{ 0x0108, 0x02 },
	{ 0x0109, 0x02 },
	{ 0x010A, 0x3D },
	{ 0x010B, 0x00 },
	{ 0x010D, 0x02 },
	{ 0x010E, 0x09 },
	{ 0x010F, 0x3D },
	{ 0x0110, 0x00 },
	{ 0x0112, 0x02 },
	{ 0x0113, 0x09 },
	{ 0x0114, 0x3D },
	{ 0x0115, 0x00 },
	{ 0x0117, 0x01 },
	{ 0x0118, 0x09 },
	{ 0x0119, 0x3B },
	{ 0x011A, 0x00 },
	{ 0x011C, 0x02 },
	{ 0x011D, 0x09 },
	{ 0x011E, 0x3D },
	{ 0x011F, 0x00 },
	{ 0x0121, 0x02 },
	{ 0x0122, 0x09 },
	{ 0x0123, 0x3D },
	{ 0x0124, 0x00 },
	{ 0x0126, 0x02 },
	{ 0x0127, 0x09 },
	{ 0x0128, 0x3D },
	{ 0x0129, 0x02 },
	{ 0x012B, 0x06 },
	{ 0x012C, 0x09 },
	{ 0x012D, 0x3D },
	{ 0x012E, 0x01 },
	{ 0x0130, 0x02 },
	{ 0x0131, 0x09 },
	{ 0x0132, 0x3D },
	{ 0x0133, 0x00 },
	{ 0x013A, 0x01 },
	{ 0x013B, 0x09 },
	{ 0x013C, 0x3B },
	{ 0x013D, 0x00 },
	{ 0x013F, 0x00 },
	{ 0x0140, 0x00 },
	{ 0x0141, 0x40 },
	{ 0x0142, 0xFF },
	{ 0x0202, 0x00 },
	{ 0x0203, 0x00 },
	{ 0x0204, 0x00 },
	{ 0x0205, 0x00 },
	{ 0x0206, 0x00 },
	{ 0x0208, 0x0D },
	{ 0x0209, 0x00 },
	{ 0x020A, 0x00 },
	{ 0x020B, 0x00 },
	{ 0x020C, 0x00 },
	{ 0x020D, 0x00 },
	{ 0x020E, 0x01 },
	{ 0x020F, 0x00 },
	{ 0x0210, 0x00 },
	{ 0x0211, 0x00 },
	{ 0x0212, 0x00 },
	{ 0x0213, 0x00 },
	{ 0x0214, 0x00 },
	{ 0x0215, 0x00 },
	{ 0x0216, 0x00 },
	{ 0x0217, 0x00 },
	{ 0x0218, 0x00 },
	{ 0x0219, 0x00 },
	{ 0x021A, 0x00 },
	{ 0x021B, 0x00 },
	{ 0x021C, 0x00 },
	{ 0x021D, 0x00 },
	{ 0x021E, 0x00 },
	{ 0x021F, 0x00 },
	{ 0x0220, 0x00 },
	{ 0x0221, 0x00 },
	{ 0x0222, 0x00 },
	{ 0x0223, 0x00 },
	{ 0x0224, 0x00 },
	{ 0x0225, 0x00 },
	{ 0x0226, 0x00 },
	{ 0x0227, 0x00 },
	{ 0x0228, 0x00 },
	{ 0x0229, 0x00 },
	{ 0x022A, 0x00 },
	{ 0x022B, 0x00 },
	{ 0x022C, 0x00 },
	{ 0x022D, 0x00 },
	{ 0x022E, 0x00 },
	{ 0x022F, 0x00 },
	{ 0x0231, 0x01 },
	{ 0x0232, 0x01 },
	{ 0x0233, 0x01 },
	{ 0x0234, 0x01 },
	{ 0x0235, 0x00 },
	{ 0x0236, 0x00 },
	{ 0x0237, 0x00 },
	{ 0x0238, 0x00 },
	{ 0x0239, 0x8C },
	{ 0x023A, 0x00 },
	{ 0x023B, 0x00 },
	{ 0x023C, 0x00 },
	{ 0x023D, 0x00 },
	{ 0x023E, 0x80 },
	{ 0x024A, 0x04 },
	{ 0x024B, 0x00 },
	{ 0x024C, 0x00 },
	{ 0x024D, 0x03 },
	{ 0x024E, 0x00 },
	{ 0x024F, 0x00 },
	{ 0x0250, 0x04 },
	{ 0x0251, 0x00 },
	{ 0x0252, 0x00 },
	{ 0x0253, 0x00 },
	{ 0x0254, 0x00 },
	{ 0x0255, 0x00 },
	{ 0x0256, 0x03 },
	{ 0x0257, 0x00 },
	{ 0x0258, 0x00 },
	{ 0x0259, 0x04 },
	{ 0x025A, 0x00 },
	{ 0x025B, 0x00 },
	{ 0x025C, 0x02 },
	{ 0x025D, 0x00 },
	{ 0x025E, 0x00 },
	{ 0x025F, 0x00 },
	{ 0x0260, 0x00 },
	{ 0x0261, 0x00 },
	{ 0x0262, 0x13 },
	{ 0x0263, 0x00 },
	{ 0x0264, 0x00 },
	{ 0x0268, 0x00 },
	{ 0x0269, 0x00 },
	{ 0x026A, 0x00 },
	{ 0x026B, 0x30 },
	{ 0x026C, 0x38 },
	{ 0x026D, 0x30 },
	{ 0x026E, 0x37 },
	{ 0x026F, 0x20 },
	{ 0x0270, 0x20 },
	{ 0x0271, 0x20 },
	{ 0x0272, 0x20 },
	{ 0x0302, 0x00 },
	{ 0x0303, 0x00 },
	{ 0x0304, 0x00 },
	{ 0x0305, 0x00 },
	{ 0x0306, 0x07 },
	{ 0x0307, 0x00 },
	{ 0x0308, 0x00 },
	{ 0x0309, 0x00 },
	{ 0x030A, 0x00 },
	{ 0x030B, 0x80 },
	{ 0x030C, 0x00 },
	{ 0x030D, 0x00 },
	{ 0x030E, 0x00 },
	{ 0x030F, 0x00 },
	{ 0x0310, 0x00 },
	{ 0x0311, 0x1C },
	{ 0x0312, 0x00 },
	{ 0x0313, 0x00 },
	{ 0x0314, 0x00 },
	{ 0x0315, 0x00 },
	{ 0x0316, 0xA0 },
	{ 0x0317, 0x00 },
	{ 0x0318, 0x00 },
	{ 0x0319, 0x00 },
	{ 0x031A, 0x00 },
	{ 0x031B, 0xB0 },
	{ 0x031C, 0x36 },
	{ 0x031D, 0x00 },
	{ 0x031E, 0x00 },
	{ 0x031F, 0x00 },
	{ 0x0320, 0x00 },
	{ 0x0321, 0xA2 },
	{ 0x0322, 0x00 },
	{ 0x0323, 0x00 },
	{ 0x0324, 0x00 },
	{ 0x0325, 0x00 },
	{ 0x0326, 0x00 },
	{ 0x0327, 0x00 },
	{ 0x0328, 0x00 },
	{ 0x0329, 0x00 },
	{ 0x032A, 0x00 },
	{ 0x032B, 0x00 },
	{ 0x032C, 0x00 },
	{ 0x032D, 0x00 },
	{ 0x032E, 0x00 },
	{ 0x032F, 0x00 },
	{ 0x0330, 0x00 },
	{ 0x0331, 0x00 },
	{ 0x0332, 0x00 },
	{ 0x0333, 0x00 },
	{ 0x0334, 0x00 },
	{ 0x0335, 0x00 },
	{ 0x0336, 0x00 },
	{ 0x0337, 0x00 },
	{ 0x0338, 0x00 },
	{ 0x0339, 0x1F },
	{ 0x033B, 0x00 },
	{ 0x033C, 0x00 },
	{ 0x033D, 0x00 },
	{ 0x033E, 0x00 },
	{ 0x033F, 0x00 },
	{ 0x0340, 0x00 },
	{ 0x0341, 0x00 },
	{ 0x0342, 0x00 },
	{ 0x0343, 0x00 },
	{ 0x0344, 0x00 },
	{ 0x0345, 0x00 },
	{ 0x0346, 0x00 },
	{ 0x0347, 0x00 },
	{ 0x0348, 0x00 },
	{ 0x0349, 0x00 },
	{ 0x034A, 0x00 },
	{ 0x034B, 0x00 },
	{ 0x034C, 0x00 },
	{ 0x034D, 0x00 },
	{ 0x034E, 0x00 },
	{ 0x034F, 0x00 },
	{ 0x0350, 0x00 },
	{ 0x0351, 0x00 },
	{ 0x0352, 0x00 },
	{ 0x0353, 0x00 },
	{ 0x0354, 0x00 },
	{ 0x0355, 0x00 },
	{ 0x0356, 0x00 },
	{ 0x0357, 0x00 },
	{ 0x0358, 0x00 },
	{ 0x0359, 0x00 },
	{ 0x035A, 0x00 },
	{ 0x035B, 0x00 },
	{ 0x035C, 0x00 },
	{ 0x035D, 0x00 },
	{ 0x035E, 0x00 },
	{ 0x035F, 0x00 },
	{ 0x0360, 0x00 },
	{ 0x0361, 0x00 },
	{ 0x0362, 0x00 },
	{ 0x0487, 0x00 },
	{ 0x0508, 0x13 },
	{ 0x0509, 0x22 },
	{ 0x050A, 0x0C },
	{ 0x050B, 0x0B },
	{ 0x050C, 0x07 },
	{ 0x050D, 0x3F },
	{ 0x050E, 0x16 },
	{ 0x050F, 0x2A },
	{ 0x0510, 0x09 },
	{ 0x0511, 0x08 },
	{ 0x0512, 0x07 },
	{ 0x0513, 0x3F },
	{ 0x0515, 0x00 },
	{ 0x0516, 0x00 },
	{ 0x0517, 0x00 },
	{ 0x0518, 0x00 },
	{ 0x0519, 0xD8 },
	{ 0x051A, 0x02 },
	{ 0x051B, 0x00 },
	{ 0x051C, 0x00 },
	{ 0x051D, 0x00 },
	{ 0x051E, 0x00 },
	{ 0x051F, 0x80 },
	{ 0x0521, 0x21 },
	{ 0x052A, 0x01 },
	{ 0x052B, 0x01 },
	{ 0x052C, 0x0F },
	{ 0x052D, 0x03 },
	{ 0x052E, 0x19 },
	{ 0x052F, 0x19 },
	{ 0x0531, 0x00 },
	{ 0x0532, 0x63 },
	{ 0x0533, 0x03 },
	{ 0x0534, 0x00 },
	{ 0x0535, 0x00 },
	{ 0x0536, 0x0C },
	{ 0x0537, 0x00 },
	{ 0x0538, 0x00 },
	{ 0x0539, 0x00 },
	{ 0x0802, 0x35 },
	{ 0x0803, 0x05 },
	{ 0x0804, 0x00 },
	{ 0x090E, 0x02 },
	{ 0x0943, 0x00 },
	{ 0x0949, 0x01 },
	{ 0x094A, 0x01 },
	{ 0x0A02, 0x00 },
	{ 0x0A03, 0x07 },
	{ 0x0A04, 0x01 },
	{ 0x0A05, 0x07 },
	{ 0x0B44, 0x2F },
	{ 0x0B46, 0x00 },
	{ 0x0B47, 0x0E },
	{ 0x0B48, 0x0E },
	{ 0x0B4A, 0x18 },
	{ 0x0514, 0x01 },
	{ 0x001C, 0x01 },
	{ 0x0540, 0x00 },
	{ 0x0B24, 0xDB },
	{ 0x0B25, 0x02 }
};


static int si5345_readPage(uint8_t *page)
{
	return i2c_regRead(SI5345_I2C_ADDRESS, SI5345_PAGE_ADDRESS, page, 1);
}


static int si5345_setPage(const uint8_t *page)
{
	uint8_t page_setReq[2] = { 0x01, *page };
	return i2c_busWrite(SI5345_I2C_ADDRESS, page_setReq, 2);
}


static int si5345_setReg(const si5345_reg_t *const reg)
{
	/* Read current page */
	uint8_t current_page = 0;
	int ret = si5345_readPage(&current_page);
	if (ret != 0) {
		fprintf(stderr, "pcie-clock: fail to read page address\n");
		return ret;
	}

	/* Make sure page is correct */
	const uint8_t desired_page = (uint8_t)((reg->address & 0xFF00) >> 8);
	if (current_page != desired_page) {
		ret = si5345_setPage(&desired_page);
		if (ret != 0) {
			fprintf(stderr, "pcie-clock: fail to write page address\n");
			return ret;
		}
	}

	/* Write register address */
	const uint8_t u8_address = (reg->address & 0xFF);
	uint8_t register_writeData[2] = { u8_address, reg->value };
	ret = i2c_busWrite(SI5345_I2C_ADDRESS, register_writeData, 2);
	if (ret != 0) {
		fprintf(stderr, "pcie-clock: fail to write reg value, error: %i\n", ret);
	}

	return ret;
}


static int si5345_uploadConfig(void)
{
	int ret = 0;
	const uint32_t config_len = (sizeof(si5345_config) / sizeof(si5345_config[0]));
	for (uint32_t i = 0; i < config_len; i++) {
		ret = si5345_setReg(&si5345_config[i]);
		if (ret != 0) {
			fprintf(stderr, "pcie-clock: failed to upload register\n");
			return ret;
		}
	}
	return ret;
}


int si5345_waitForCalibration(void)
{
	static const uint32_t readout_periodUs = 250;
	static const uint32_t log_msgPeriodUs = 100 * 1000;
	static const uint32_t timeoutUs = 500000;

	/* Read a few debug registers */
	uint8_t internal_statusReg = 0;
	uint8_t lock_status = 0;
	uint8_t alarms_status = 0;
	uint8_t calibration_status = 0;
	uint8_t internal_errorFlags = 0;
	int ret = i2c_regRead(0x69, 0x0C, &internal_statusReg, 1);
	ret |= i2c_regRead(0x69, 0x0E, &lock_status, 1);
	ret |= i2c_regRead(0x69, 0x0D, &alarms_status, 1);
	ret |= i2c_regRead(0x69, 0x11, &internal_errorFlags, 1);
	if (ret != 0) {
		fprintf(stderr, "pcie-clock: failed i2c transaction\n");
		return -1;
	}

	uint32_t time_passedUs = 0;
	uint32_t calibration_busy = 1;
	while (calibration_busy == 1) {
		/* Perdiodically check chip status */
		time_passedUs += readout_periodUs;
		usleep(readout_periodUs);
		ret |= i2c_regRead(0x69, 0x0C, &internal_statusReg, 1);
		ret |= i2c_regRead(0x69, 0x0F, &calibration_status, 1);
		if (ret != 0) {
			continue;
		}

		/* Check if calibration is done */
		calibration_busy = ((((calibration_status) & (0x20)) >> 5) | ((internal_statusReg) & (0x01)));

		/* Periodically log status */
		if ((time_passedUs % log_msgPeriodUs) == 0) {
			printf("pcie-clock: int. status 0x%x, lock 0x%x, alarms 0x%x, err. flags %x, cal. status %x waiting for %u us\n",
					internal_statusReg, lock_status, alarms_status, internal_errorFlags, calibration_status, time_passedUs);
		}

		/* Check timeout condition */
		if (time_passedUs >= timeoutUs) {
			fprintf(stderr, "pcie-clock: fail, calibration not finished after %u us\n", time_passedUs);
			return -1;
		}
	}

	return 0;
}


int pcie_clockInitSi5345(void)
{
	/* Init I2C 0 */
	int ret = i2c_init(0);
	if (ret != 0) {
		fprintf(stderr, "pcie-clock: fail to init i2c err %i\n", ret);
		return ret;
	}

	/* Disable all U16 I2C multiplexer channels */
	uint8_t data = 0;
	ret = i2c_busWrite(0x73, &data, 1);
	if (ret != 0) {
		fprintf(stderr, "pcie-clock: fail to config i2c multiplexer: %i\n", ret);
		return ret;
	}

	/* Enable only one channel of U27: PLL chip */
	data = (1 << 4);
	ret = i2c_busWrite(0x77, &data, 1);
	if (ret != 0) {
		fprintf(stderr, "pcie-clock: fail to config i2c multiplexer: %i\n", ret);
		return ret;
	}

	/* Read SI5345 whoami */
	uint8_t whoami_page = 0;
	ret = si5345_setPage(&whoami_page);
	if (ret != 0) {
		fprintf(stderr, "pcie-clock: fail to write page address\n");
		return ret;
	}
	uint8_t chip_id[4] = { 0 };
	ret = i2c_regRead(0x69, 0x02, chip_id, 4);
	if (ret != 0) {
		fprintf(stderr, "pcie-clock: fail to read si5345 whoami: %i\n", ret);
		return ret;
	}

	if ((chip_id[0] == 0x45) && (chip_id[1] == 0x53)) {
		printf("pcie-clock: si5345 chip id valid (0x%x%x) \n", chip_id[1], chip_id[0]);
	}
	else {
		fprintf(stderr, "pcie-clock: si5345 chip id invalid 0x%x 0x%x 0x%x 0x%x \n",
				chip_id[0], chip_id[1], chip_id[2], chip_id[3]);
	}

	/* Configure SI5345 */
	ret = si5345_uploadConfig();
	if (ret != 0) {
		fprintf(stderr, "pcie-clock: fail to upload si5345 config: err %i\n", ret);
		return ret;
	}

	usleep(5);

	return si5345_waitForCalibration();
}


static int pcie_clockConfigResetPin(void)
{
	/* Configure MIO multiplexer */
	platformctl_t ctl;
	ctl.action = pctl_set;
	ctl.type = pctl_mio;
	ctl.mio.pin = 31;
	ctl.mio.l0 = ctl.mio.l1 = ctl.mio.l2 = ctl.mio.l3 = 0;
	ctl.mio.config = PCTL_MIO_DRIVE_12mA;
	int ret = platformctl(&ctl);

	/* Set MIO31 direction as output */
	writeRegMsk(common.gpio, 0x244, 0x20, 0x20);
	/* Set MIO31 output enable */
	writeRegMsk(common.gpio, 0x248, 0x20, 0x20);

	return ret;
}


static void pcie_clockAssertReset(void)
{
	/* Set MIO31 to LOW */
	writeRegMsk(common.gpio, 0x44, 0x20, 0x00);
}


static void pcie_clockDeAssertReset(void)
{
	/* Set MIO31 to HIGH */
	writeRegMsk(common.gpio, 0x44, 0x20, 0x20);
}


int tebf0808_pcieRefClkInit(void)
{
	/* Map GPIO register set */
	common.gpio = mmap(NULL, GPIO_REG_SET_SIZE, PROT_WRITE | PROT_READ,
			MAP_DEVICE | MAP_PHYSMEM | MAP_ANONYMOUS, -1, GPIO_REG_SET_ADDR);
	if (MAP_FAILED == common.gpio) {
		fprintf(stderr, "pcie-clock: fail to map GPIO registers memory\n");
		return EXIT_FAILURE;
	}

	/* Initialize PCI Express reset pin */
	if (pcie_clockConfigResetPin() < 0) {
		fprintf(stderr, "pcie-clock: fail to init reset pin\n");
		munmap((void *)common.gpio, GPIO_REG_SET_SIZE);
		return EXIT_FAILURE;
	}

	/* Assert PCI Express reset */
	pcie_clockAssertReset();

	if (pcie_clockInitSi5345() != 0) {
		fprintf(stderr, "pcie-clock: failed to configure chip\n");
		munmap((void *)common.gpio, GPIO_REG_SET_SIZE);
		return EXIT_FAILURE;
	}
	else {
		printf("pcie-clock: si5345 config success\n");
	}

	/* Deassert PCIE EXpress reset */
	pcie_clockDeAssertReset();

	/* Unmap register set */
	munmap((void *)common.gpio, GPIO_REG_SET_SIZE);

	return EXIT_SUCCESS;
}
